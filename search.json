[{"title":"kotlin 基本类型","url":"/2023/07/14/kotlin-basic-types/","content":"基本类型在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。\n\n\n\n原文地址，此处仅作展示！\n\n基本类型在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。\n数字Kotlin 提供了一组表示数字的内置类型。对于整数，有四种不同大小的类型，因此值的范围也不同。\n\n\n\n类型\n大小（比特数）\n最小值\n最大值\n\n\n\nByte\n8\n-128\n127\n\n\nShort\n16\n-32768\n32767\n\n\nInt\n32\n-2,147,483,648 (-231)\n2,147,483,647 (231 - 1)\n\n\nLong\n64\n-9,223,372,036,854,775,808 (-263)\n9,223,372,036,854,775,807 (263 - 1)\n\n\n所有以未超出 Int 最大值的整型值初始化的变量都会推断为 Int 类型。如果初始值超过了其最大值，那么推断为 Long 类型。如需显式指定 Long 型值，请在该值后追加 L 后缀。\nval one = 1 // Intval threeBillion = 3000000000 // Longval oneLong = 1L // Longval oneByte: Byte = 1\n\n对于浮点数，Kotlin 提供了 Float 与 Double 类型。根据 IEEE 754 标准，两种浮点类型的十进制位数（即可以存储多少位十进制数）不同。Float 反映了 IEEE 754 单精度，而 Double 提供了双精度。\n\n\n\n类型\n大小（比特数）\n有效数字比特数\n指数比特数\n十进制位数\n\n\n\nFloat\n32\n24\n8\n6-7\n\n\nDouble\n64\n53\n11\n15-16\n\n\n对于以小数初始化的变量，编译器会推断为 Double 类型。如需将一个值显式指定为 Float 类型，请添加 f 或 F 后缀。如果这样的值包含多于 6～7 位十进制数，那么会将其舍入。\nval pi = 3.14 // Doubleval e = 2.7182818284 // Doubleval eFloat = 2.7182818284f // Float，实际值为 2.7182817\n\n请注意，与一些其他语言不同，Kotlin 中的数字没有隐式拓宽转换。例如，具有 Double 参数的函数只能对 Double 值调用，而不能对 Float、Int 或者其他数字值调用。\nfun main() &#123;    fun printDouble(d: Double) &#123; print(d) &#125;    val i = 1        val d = 1.1    val f = 1.1f     printDouble(d)//    printDouble(i) // 错误：类型不匹配//    printDouble(f) // 错误：类型不匹配&#125;\n\n如需将数值转换为不同的类型，请使用显示转换。\n字面常量数值常量字面值有以下几种:\n\n十进制: 123\nLong 类型用大写 L 标记: 123L\n\n\n十六进制: 0x0F\n二进制: 0b00001011\n\n注意: 不支持八进制\nKotlin 同样支持浮点数的常规表示方法:\n\n默认 double：123.5、123.5e10\nFloat 用 f 或者 F 标记: 123.5f\n\n数字字面值中的下划线（自 1.1 起）你可以使用下划线使数字常量更易读：\nval oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010\n\n表示方式在 Java 平台数字是物理存储为 JVM 的原生类型，除非我们需要一个可空的引用（如 Int?）或泛型。后者情况下会把数字装箱。\n注意数字装箱不一定保留同一性:\nfun main() &#123;    val a: Int = 100    val boxedA: Int? = a    val anotherBoxedA: Int? = a        val b: Int = 10000    val boxedB: Int? = b    val anotherBoxedB: Int? = b        println(boxedA === anotherBoxedA) // true    println(boxedB === anotherBoxedB) // false&#125;\n\n另一方面，它保留了相等性:\nfun main() &#123;    val a: Int = 10000    println(a == a) // 输出“true”    val boxedA: Int? = a    val anotherBoxedA: Int? = a    println(boxedA == anotherBoxedA) // 输出“true”&#125;\n\n显式转换由于不同的表示方式，较小类型并不是较大类型的子类型。如果它们是的话，就会出现下述问题：\n// 假想的代码，实际上并不能编译：val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)print(b == a) // 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long\n\n所以相等性会在所有地方悄无声息地失去，更别说同一性了。\n因此较小的类型不能隐式转换为较大的类型。这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。\nfun main() &#123;    val b: Byte = 1 // OK, 字面值是静态检测的    val i: Int = b // 错误&#125;\n\n我们可以显式转换来拓宽数字\nfun main() &#123;    val b: Byte = 1    val i: Int = b.toInt() // OK：显式拓宽    print(i)&#125;\n\n每个数字类型支持如下的转换:\n\ntoByte(): Byte\ntoShort(): Short\ntoInt(): Int\ntoLong(): Long\ntoFloat(): Float\ntoDouble(): Double\ntoChar(): Char\n\n缺乏隐式类型转换很少会引起注意，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如：\nval l = 1L + 3 // Long + Int =&gt; Long\n\n运算Kotlin支持数字运算的标准集（+ - * / %），运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。参见运算符重载。\n整数除法请注意，整数间的除法总是返回整数。会丢弃任何小数部分。例如：\nfun main() &#123;    val x = 5 / 2    //println(x == 2.5) // ERROR: Operator &#x27;==&#x27; cannot be applied to &#x27;Int&#x27; and &#x27;Double&#x27;    println(x == 2)&#125;\n\n对于任何两个整数类型之间的除法来说都是如此。\nfun main() &#123;    val x = 5L / 2    println(x == 2L)&#125;\n\n如需返回浮点类型，请将其中的一个参数显式转换为浮点类型。\nfun main() &#123;    val x = 5 / 2.toDouble()    println(x == 2.5)&#125;\n\n位运算对于位运算，没有特殊字符来表示，而只可用中缀方式调用具名函数，例如:\nval x = (1 shl 2) and 0x000FF000\n\n这是完整的位运算列表（只用于 Int 与 Long）：\n\nshl(bits) – 有符号左移\nshr(bits) – 有符号右移\nushr(bits) – 无符号右移\nand(bits) – 位与\nor(bits) – 位或\nxor(bits) – 位异或\ninv() – 位非\n\n浮点数比较本节讨论的浮点数操作如下：\n\n相等性检测：a == b 与 a != b\n比较操作符：a &lt; b、 a &gt; b、 a &lt;= b、 a &gt;= b\n区间实例以及区间检测：a..b、 x in a..b、 x !in a..b\n\n当其中的操作数 a 与 b 都是静态已知的 Float 或 Double 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者智能类型转换的结果是该类型），两数字所形成的操作或者区间遵循 IEEE 754 浮点运算标准。\n然而，为了支持泛型场景并提供全序支持，当这些操作数并非静态类型为浮点数（例如是 Any、 Comparable&lt;……&gt;、 类型参数）时，这些操作使用为 Float 与 Double 实现的不符合标准的 equals 与 compareTo，这会出现：\n\n认为 NaN 与其自身相等\n认为 NaN 比包括正无穷大（POSITIVE_INFINITY）在内的任何其他元素都大\n认为 -0.0 小于 0.0\n\n字符字符用 Char 类型表示。它们不能直接当作数字\nfun check(c: Char) &#123;    if (c == 1) &#123; // 错误：类型不兼容        // ……    &#125;&#125;\n\n字符字面值用单引号括起来: &#39;1&#39;。特殊字符可以用反斜杠转义。支持这几个转义序列：\\t、 \\b、\\n、\\r、\\&#39;、\\&quot;、\\\\ 与 \\$。编码其他字符要用 Unicode 转义序列语法：&#39;\\uFF00&#39;。\n我们可以显式把字符转换为 Int 数字：\nfun decimalDigitValue(c: Char): Int &#123;    if (c !in &#x27;0&#x27;..&#x27;9&#x27;)        throw IllegalArgumentException(&quot;Out of range&quot;)    return c.toInt() - &#x27;0&#x27;.toInt() // 显式转换为数字&#125;\n\n当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。\n布尔布尔用 Boolean 类型表示，它有两个值：true{: .keyword } 与 false{: .keyword }。\n若需要可空引用布尔会被装箱。\n内置的布尔运算有：\n\n|| – 短路逻辑或\n&amp;&amp; – 短路逻辑与\n! - 逻辑非\n\n数组数组在 Kotlin 中使用 Array 类来表示，它定义了 get 与 set 函数（按照运算符重载约定这会转变为 []）以及 size 属性，以及一些其他有用的成员函数：\nclass Array&lt;T&gt; private constructor() &#123;    val size: Int    operator fun get(index: Int): T    operator fun set(index: Int, value: T): Unit    operator fun iterator(): Iterator&lt;T&gt;    // ……&#125;\n\n我们可以使用库函数 arrayOf() 来创建一个数组并传递元素值给它，这样 arrayOf(1, 2, 3) 创建了 array [1, 2, 3]。或者，库函数 arrayOfNulls() 可以用于创建一个指定大小的、所有元素都为空的数组。\n另一个选项是用接受数组大小以及一个函数参数的 Array 构造函数，用作参数的函数能够返回给定索引的每个元素初始值：\nfun main() &#123;    // 创建一个 Array&lt;String&gt; 初始化为 [&quot;0&quot;, &quot;1&quot;, &quot;4&quot;, &quot;9&quot;, &quot;16&quot;]    val asc = Array(5) &#123; i -&gt; (i * i).toString() &#125;    asc.forEach &#123; println(it) &#125;&#125;\n\n如上所述，[] 运算符代表调用成员函数 get() 与 set()。\nKotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 Array&lt;String&gt;赋值给 Array&lt;Any&gt;，以防止可能的运行时失败（但是你可以使用 Array&lt;out Any&gt;,参见类型投影）。\n原生类型数组Kotlin 也有无装箱开销的专门的类来表示原生类型数组: ByteArray、ShortArray、IntArray 等等。这些类与 Array 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法:\nval x: IntArray = intArrayOf(1, 2, 3)x[0] = x[1] + x[2]\n\n// 大小为 5、值为 [0, 0, 0, 0, 0] 的整型数组val arr = IntArray(5)// 例如：用常量初始化数组中的值// 大小为 5、值为 [42, 42, 42, 42, 42] 的整型数组val arr = IntArray(5) &#123; 42 &#125;// 例如：使用 lambda 表达式初始化数组中的值// 大小为 5、值为 [0, 1, 2, 3, 4] 的整型数组（值初始化为其索引值）var arr = IntArray(5) &#123; it * 1 &#125; \n\n\n无符号整型\n无符号类型自 Kotlin 1.3 起才可用，并且目前是实验性的。详见下文{:.note}\n\nKotlin 为无符号整数引入了以下类型：\n\nkotlin.UByte: 无符号 8 比特整数，范围是 0 到 255\nkotlin.UShort: 无符号 16 比特整数，范围是 0 到 65535\nkotlin.UInt: 无符号 32 比特整数，范围是 0 到 2^32 - 1\nkotlin.ULong: 无符号 64 比特整数，范围是 0 到 2^64 - 1\n\n无符号类型支持其对应有符号类型的大多数操作。\n\n请注意，将类型从无符号类型更改为对应的有符号类型（反之亦然）是二进制不兼容变更{:.note}\n\n无符号类型是使用另一个实验性特性（即内联类）实现的。\n特化的类与原生类型相同，每个无符号类型都有相应的为该类型特化的表示数组的类型：\n\nkotlin.UByteArray: 无符号字节数组\nkotlin.UShortArray: 无符号短整型数组\nkotlin.UIntArray: 无符号整型数组\nkotlin.ULongArray: 无符号长整型数组\n\n与有符号整型数组一样，它们提供了类似于 Array 类的 API 而没有装箱开销。\n此外，区间与数列也支持 UInt 与 ULong（通过这些类 kotlin.ranges.UIntRange、 kotlin.ranges.UIntProgression、 kotlin.ranges.ULongRange、 kotlin.ranges.ULongProgression）\n字面值为使无符号整型更易于使用，Kotlin 提供了用后缀标记整型字面值来表示指定无符号类型（类似于 Float&#x2F;Long）：\n\n后缀 u 与 U 将字面值标记为无符号。确切类型会根据预期类型确定。如果没有提供预期的类型，会根据字面值大小选择 UInt 或者 ULong\n\nval b: UByte = 1u  // UByte，已提供预期类型val s: UShort = 1u // UShort，已提供预期类型val l: ULong = 1u  // ULong，已提供预期类型val a1 = 42u // UInt：未提供预期类型，常量适于 UIntval a2 = 0xFFFF_FFFF_FFFFu // ULong：未提供预期类型，常量不适于 UInt\n\n\n后缀 uL 与 UL 显式将字面值标记为无符号长整型。\n\nval a = 1UL // ULong，即使未提供预期类型并且常量适于 UInt\n\n无符号整型的实验性状态无符号类型的设计是实验性的，这意味着这个特性改进很快并且没有给出兼容性保证。当在 Kotlin 1.3+ 中使用无符号算术时，会报出警告表明这个特性是实验性的。如需移除警告，必须选择加入（opt-in）无符号类型的实验性使用。\n选择加入无符号整型有两种可行的方式：将 API 标记为实验性的，或者无需标记。\n\n如需传播实验性，请以 @ExperimentalUnsignedTypes 标注使用了无符号整型的声明。\n如需选择加入而不传播实验性，要么使用 @OptIn(ExperimentalUnsignedTypes::class) 注解标注声明，要么将 -Xopt-in=kotlin.ExperimentalUnsignedTypes 传给编译器。\n\n你的客户是否必须选择使用你的 API 取决于你，不过请记住，无符号整型是一个实验性特性，因此使用它们的 API 可能会因语言的变更而发生突然破坏。\n技术细节也参见实验性 API KEEP。\n深入探讨关于技术细节与深入探讨请参见无符号类型的语言提案。\n字符串字符串用 String 类型表示。字符串是不可变的。字符串的元素——字符可以使用索引运算符访问: s[i]。可以用 for{: .keyword } 循环迭代字符串:\nfun main() &#123;    val str = &quot;abcd&quot;    for (c in str) &#123;        println(c)    &#125;&#125;\n\n可以用 + 操作符连接字符串。这也适用于连接字符串与其他类型的值，只要表达式中的第一个元素是字符串：\nfun main() &#123;val s = &quot;abc&quot; + 1println(s + &quot;def&quot;)&#125;\n\n请注意，在大多数情况下，优先使用字符串模板或原始字符串而不是字符串连接。\n字符串字面值Kotlin 有两种类型的字符串字面值: 转义字符串可以有转义字符，以及原始字符串可以包含换行以及任意文本。以下是转义字符串的一个示例:\nval s = &quot;Hello, world!\\n&quot;\n\n转义采用传统的反斜杠方式。参见上面的 字符 查看支持的转义序列。\n原始字符串 使用三个引号（&quot;&quot;&quot;）分界符括起来，内部没有转义并且可以包含换行以及任何其他字符:\nval text = &quot;&quot;&quot;    for (c in &quot;foo&quot;)        print(c)&quot;&quot;&quot;\n\n你可以通过 trimMargin() 函数去除前导空格：\nval text = &quot;&quot;&quot;    |Tell me and I forget.    |Teach me and I remember.    |Involve me and I learn.    |(Benjamin Franklin)    &quot;&quot;&quot;.trimMargin()\n\n默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(&quot;&gt;&quot;)。\n字符串模板字符串字面值可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。模板表达式以美元符（$）开头，由一个简单的名字构成:\nfun main() &#123;    val i = 10    println(&quot;i = $i&quot;) // 输出“i = 10”&#125;\n\n或者用花括号括起来的任意表达式:\nfun main() &#123;    val s = &quot;abc&quot;    println(&quot;$s.length is $&#123;s.length&#125;&quot;) // 输出“abc.length is 3”&#125;\n\n原始字符串与转义字符串内部都支持模板。如果你需要在原始字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：\nval price = &quot;&quot;&quot;$&#123;&#x27;$&#x27;&#125;9.99&quot;&quot;&quot;\n","categories":["example"],"tags":["note"]},{"title":"helloworld","url":"/2023/07/13/helloworld/","content":"JavaScriptconsole.log(&quot;Hello World&quot;);\n记一些代码示例~~~\n\n\nApache# rewrite`s rules for wordpress pretty urlLoadModule rewrite_module  modules/mod_rewrite.soRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule . index.php [NC,L]ExpiresActive OnExpiresByType application/x-javascript  &quot;access plus 1 days&quot;Order Deny,AllowAllow from All&lt;Location /maps/&gt;  RewriteMap map txt:map.txt  RewriteMap lower int:tolower  RewriteCond %&#123;REQUEST_URI&#125; ^/([^/.]+)\\.html$ [NC]  RewriteCond $&#123;map:$&#123;lower:%1&#125;|NOT_FOUND&#125; !NOT_FOUND  RewriteRule .? /index.php?q=$&#123;map:$&#123;lower:%1&#125;&#125; [NC,L]&lt;/Location&gt;\n\nBash#!/bin/bash###### CONFIGACCEPTED_HOSTS=&quot;/root/.hag_accepted.conf&quot;BE_VERBOSE=falseif [ &quot;$UID&quot; -ne 0 ]then echo &quot;Superuser rights required&quot; exit 2figenApacheConf()&#123; echo -e &quot;# Host $&#123;HOME_DIR&#125;$1/$2 :&quot;&#125;echo &#x27;&quot;quoted&quot;&#x27; | tr -d \\&quot; &gt; text.txt\n\nCoffeeScriptgrade = (student, period=(if b? then 7 else 6)) -&gt;  if student.excellentWork    &quot;A+&quot;  else if student.okayStuff    if student.triedHard then &quot;B&quot; else &quot;B-&quot;  else    &quot;C&quot;class Animal extends Being  constructor: (@name) -&gt;  move: (meters) -&gt;    alert @name + &quot; moved #&#123;meters&#125;m.&quot;\n\nC++#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123;  /* An annoying &quot;Hello World&quot; example */  for (auto i = 0; i &lt; 0xFFFF; i++)    cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;  char c = &#x27;\\n&#x27;;  unordered_map &lt;string, vector&lt;string&gt; &gt; m;  m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error  return -2e3 + 12l;&#125;\n\nC#using System.IO.Compression;#pragma warning disable 414, 3021namespace MyApplication&#123;    [Obsolete(&quot;...&quot;)]    class Program : IInterface    &#123;        public static List&lt;int&gt; JustDoIt(int count)        &#123;            Console.WriteLine($&quot;Hello &#123;Name&#125;!&quot;);            return new List&lt;int&gt;(new int[] &#123; 1, 2, 3 &#125;)        &#125;    &#125;&#125;\n\nCSS@font-face &#123;  font-family: Chunkfive; src: url(&#x27;Chunkfive.otf&#x27;);&#125;body, .usertext &#123;  color: #F0F0F0; background: #600;  font-family: Chunkfive, sans;  --heading-1: 30px/32px Helvetica, sans-serif;&#125;@import url(print.css);@media print &#123;  a[href^=http]::after &#123;    content: attr(href)  &#125;&#125;\n\ndiffIndex: languages/ini.js===================================================================--- languages/ini.js    (revision 199)+++ languages/ini.js    (revision 200)@@ -1,8 +1,7 @@ hljs.LANGUAGES.ini = &#123;   case_insensitive: true,-  defaultMode:-  &#123;+  defaultMode: &#123;     contains: [&#x27;comment&#x27;, &#x27;title&#x27;, &#x27;setting&#x27;],     illegal: &#x27;[^\\\\s]&#x27;   &#125;,*** /path/to/original timestamp--- /path/to/new      timestamp****************** 1,3 ****--- 1,9 ----+ This is an important+ notice! It should+ therefore be located at+ the beginning of this+ document!! compress the size of the! changes.  It is important to spell\n\n\n查看更多示例：Highlight.js demo\n\n","categories":["example"],"tags":["note"]},{"title":"测试","url":"/2023/07/12/%E6%B5%8B%E8%AF%95/","content":"标题一标题二标题三标题四标题五这是加粗\n这是斜体\n这是横线\n\n无序列表\n无序列表\n\n\n有序列表\n有序列表\n\n内嵌代码\n代码块\n\n\n引用\n\n","categories":["测试"],"tags":["testing"]},{"title":"termux使用记录","url":"/2023/07/15/termux-01/","content":"\n前言：一次日记我与初次认识termux大概是在上初中那会，当时termux还处于不冷不热的状态，最后还是在国光大佬写的一篇关于termux文章下系统的学习了相关的知识，这次经历可谓是对我的后来乃至现在都受益匪浅（因为当时没有电脑，只有手机），这篇文章涉及了很多程序语言，例如java，python，go…..等等，还有linux系统的相关指令，是及其优秀的一篇文章，当然这还有许多。\n\n\n\n国光大佬的原文地址\n\ntermux利用python爬取b站并入库首先保证 mysql 与 python3 完整安装，在 termux中 mysql 安装可用 pkg install mariadb命令安装。\ntermux中mariabd的基本配置可以参考官方文档\ntermux官方文档mariadb官方文档\n\n过程#启动mysql服务（得到一个进程号（pid号），nohup: ignoring input and appending output to `nohup.out&#x27;提示也是正常的）nohup mysqld &amp;#进入mysql(whoami为本机的登陆名)mysql -u $&#123;whoami&#125;#mysql内修改root密码，我这里习惯设置用户名密码都为rootuse mysql;set password for &#x27;root&#x27;@&#x27;localhost&#x27; = password(&#x27;root&#x27;);# 刷新权限flush privileges;# 创建数据库create database bilidb;use bilidb;CREATE TABLE `hot` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `hotword` varchar(200) CHARACTER SET utf8 DEFAULT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `hotword` (`hotword`)) ENGINE=InnoDB AUTO_INCREMENT=67 DEFAULT CHARSET=latin1;#退出mysqlquit;#需要关闭mysql服务可以掉进程kill -9 PID(这个pid号启动服务的时候回显示)\n\n运行python程序# python +文件名例子：python hello-world.py# 注意，部分手机受安卓11系统应用文件的限制，termux可能无法访问其他文件目录的文件，所以建议将需要的文件放在termux当下的目录位置\n\n编写爬虫程序#python程序#字典import requestsimport jsonimport pymysql.cursors#加头标识headers = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.77 Safari/537.36&#x27;&#125;product=[]#获取传回数据resp=requests.get(&#x27;https://s.search.bilibili.com/main/hotword?mid=&amp;buvid=98E676EF-F586-403E-8440-52A6836FA68713451infoc&amp;jsonp=jsonp&amp;callback=jsonCallback_bili_58910703464582290&#x27;,headers=headers)rest=resp.text.replace(&#x27;jsonCallback_bili_58910703464582290(&#x27;,&#x27;&#x27;).replace(&#x27;)&#x27;,&#x27;&#x27;)    #转换json键值对json_data=json.loads(rest)comments=json_data[&quot;list&quot;]#     #把想要的数据装入列表中proDict=[]for item in comments:    proDict.append(item[&#x27;keyword&#x27;]+&#x27; &#x27;)product.extend(proDict)# 把数组里所有数据都转入字符串中（这里是学习用的，可以去除）p=&#x27;&#x27;.join(proDict)print(p)# 数据入库# 连接数据库conn = pymysql.connect(          host=&#x27;127.0.0.1&#x27;,          port=3306,          user=&#x27;root&#x27;,          passwd=&#x27;root&#x27;,          db=&#x27;bilidb&#x27;,          charset=&#x27;utf8&#x27;,          cursorclass=pymysql.cursors.Cursor,         )cur=conn.cursor()#这里用replace解决数据入库时重复数据的问题，注意hotword字段要设置唯一约束for item in proDict:        cur.execute(&quot;replace into hot(hotword) values(&#x27;%s&#x27;)&quot; %(item))#事务提交（这里尝试性的用了一个异常处理，嘿嘿可以去掉）try:          conn.commit()except AttributeError:    print(&quot;错误&quot;)cur.close()\n注：最上面的 import &lt;模块名称&gt;，中引入的模块需要确保已经安装，否则会出现模块缺失报错\n最后将上面的文件保存后直接运行\n在 termux 中依次输入下面图中的命令\n在termux中加入定时任务，每分钟爬一次入库#安装crontabpkg install crontab#启动服务crond#编辑定时任务crontab -e#输入定时任务* * * * * python bili.py &gt;&gt;123.log星号分别表示 分 时 天 月份 周 可以指定时间运行，若为星号就代表每分或每周或每时...运行，我这里是每分钟运行一次，若要每天则要确定具体时间即 0 8 * * * 这就表示每天8点运行（后面具体复杂操作见https://www.runoob.com/linux/linux-comm-crontab.html）然后后面就是指令了，***注意的是后面必须要指定一个log文件***，不然它不会运行.\n\n运行示例\n","categories":["example"],"tags":["log"]},{"title":"ryujinx模拟器日志","url":"/2023/07/15/ryujinx-log/","content":"\n\n\n原因在玩 switch 游戏时发现某些游戏在打了中文补丁（也被称为汉化补丁）之后，出现乱码的情况。\n问题解决办法故障排查总结：\n1：模拟器版本不兼容2：固件不支持该游戏3：密钥不是最新\n例如 月姬remake 的中文补丁就不支持 ryujinx1.1.953目前找到的最新支持版本为：ryujinx1.1.658\n\n\n\nryujinx1.1.658月姬remake中文补丁与本体\n\n","categories":["模拟器日志"],"tags":["log"]}]